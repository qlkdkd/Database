# 5. 관계 데이터 모델

---

# 1. 관계 데이터 모델의 개념

## 관계 데이터 모델의 기본 개념
* 개념적 구조를 논리적 구조로 표현하는 논리적 데이터 모델
* 하나의 개체에 관한 데이터를 하나의 릴레이션에 저장
![image](https://github.com/qlkdkd/Database/assets/71871927/93c44d1e-292a-42ae-94c0-90327e2e6b11)

## 관계 데이터 모델의 기본 용어
* 릴레이션(relation): 하나의 개체에 관한 데이터를 2차원 테이블의 구조로 저장한 것, 파일 관리 시스템 관점에서 파일에 대응
* 속성(attribute): 릴레이션의 열, 파일관리시스템에서 필드에 대응
    * 고객 릴레이션에서 고객아이디, 고객이름, 나이, 등급, 직업, 적립금 총 6개의 속성이 존재
* 투플(tuple): 릴레이션의 행, 파일관리시스템에서 레코드에 대응
    * 고객 릴레이션에서 4개의 투플이 존재
* 도메인(domain): 속성 하나가 가질 수 있는 모든 값의 집합, 속성 값을 입력 및 수정할 때 적합성 판단의 기준이 됨
    * 일반적으로 속성의 특성을 고려한 데이터 타입으로 정의
* 널: 속성 값을 아직 모르거나 해당되는 값이 없음을 표현
* 차수(degree): 하나의 릴레이션에서 속성의 전체 개수(예: 고객 릴레이션의 차수는 6)
* 카디널리티(cardinality): 하나의 릴레이션에서 튜플의 전체 개수(예: 고객 릴레이션의 카디널리티: 4)

## 릴레이션의 구성
* 릴레이션 스키마(내포)(relation schema(intension)): 릴레이션의 의 이름과 릴레이션에 포함된 모든 속성의 이름으로 정의하는 릴레이션의 논리적 구조(예: 고객(고객아이디, 고객이름, 나이, 등급, 직업, 적립금), 자주 변하지 않는 정적 특징
* 릴레이션 인스턴스(relation instance): 어느 한 시점에 릴레이션에 존재하는 튜플들의 집합(예: 고객 릴레이션에서는 4개의 튜플로 구성된 릴레이션 인스턴스 확인 가능), 튜플의 삽입, 삭제, 수정이 자주 발생하는 동적 특징

![image](https://github.com/qlkdkd/Database/assets/71871927/5205657f-6585-4703-a42b-e707e74191df)

## 데이터베이스의 구성
* 데이터베이스 스키마:DB의 구조, DB를 구성하는 릴레이션 스키마의 모음
* 데이터베이스 인스턴스: DB를 구성하는 릴레이션의 인스턴스의 모음
![image](https://github.com/qlkdkd/Database/assets/71871927/35af4253-f6ce-49d3-94a2-e5237cb51024)

## 릴레이션의 특성
* 튜플의 유일성: 하나의 릴레이션에는 동일한 튜플이 존재할 수 없다.
    * 하나의 릴레이션에 똑같은 튜플이 있으면 안되고, 모든 튜플에는 다른 튜플과 구별되는 유일한 특성이 있어야 된다.
    * 관계 데이터 모델의 릴레이션에서는 하나 또는 여러개의 속성을 미리 선정해두고 이 속성값을 투플마다 다르게 지정하여 튜플의 유일성을 판단함. (예: 고객 릴레이션에서 고객아이디의 속성값으로 모든 고객 튜플을 유일하게 구분하여 고객이 중복 가입하는 일을 방지함)

* 튜플의 무순서: 하나의 릴레이션에서 투플 사이의 순서는 무의미하다
    * 투플 순서가 바뀐다고 다른 릴레이션이 될 수 없고, 순서와 상관없이 투플 내용이 같아야 같은 릴레이션이다.
* 속성의 무순서: 하나의 릴레이션에서 속성 사이의 순서는 무의미하다.
    * 속성은 순서가 바뀌어도 다른 릴레이션이 될 수 없고, 같은 속성들로 구성되어 있어야 같은 릴레이션이다.
* 속성의 원자성: 속성 값으로 원자 값만 사용할 수 없다.
    * 하나의 속성은 여러 개의 값, 즉 다중 값을 가질 수 없다.
        * 예: (그림 5-4)의 고객 릴레이션은 (회사원, 학생)과 같이 값이 여러개인 직업 속성을 포함하므로 관계 데이터모델의 릴레이션으로 적합하지 않다.
     ![image](https://github.com/qlkdkd/Database/assets/71871927/1b12310b-597d-4bf4-a2b2-38b91cfd95b2)

## 키의 종류
* 릴레이션에 포함된 투플들을 유일하게 구별해주는 역할은 속성 또는 속성들의 집합인 키가 담당
* 키의 특성
   * 유일성(uniqueness): 하나의 릴레이션에서 모든 투플은 서로 다른 키 값을 가져야 함
   * 최소성(minimality): 꼭 필요한 최소한의 속성들로만 키를 구성
 ![image](https://github.com/qlkdkd/Database/assets/71871927/77782b58-2f72-46cb-82c3-c3ccd753ae01)

### 슈퍼키(super key)
* 유일성의 특성을 만족하는 속성 또는 속성들의 집합
* 하나의 릴레이션에서 키로 지정된 속성 값은 투플마다 달라야 함
* 예) 고객 릴레이션의 수퍼키: 고객아이디 등

### 후보키(candidate key)
* 유일성을 만족하는 속성 또는 속성들의 집합
* 최소성: 꼭 필요한 최소한의 속성들로만 키를 구성하는 특성
* 후보키는 투플을 유일하게 구별하기 위해 꼭 필요한 최소한의 속성들로만 이루어지므로 슈퍼키 중에서 최소성을 만족하는 것이 후보키가 된다.
* 후보키가 되기 위해 만족해야 하는 유일성과 최소성의 특성은 새로운 투플이 삽입되거나 기존 투플의 속성 값이 바뀌어도 만족하지 않는다.
* 예) 고객 릴레이션의 후보키: 고객아이디 등

## 기본키(primary key)
* 후보키 중에서 기본적으로 사용하기 위해 선택한 키
* 예) 고객 릴레이션의 기본키: 고객 아이디(고객 릴레이션에서 후보키가 고객아이디 딱 한개이므로 자연스레 고객아이디가 기본키가 됨)
   * 널 값을 가질 수 있는 속성이 포함된 후보키는 기본키로 부적합함
   * 값이 자주 변경될 수 있는 속성이 포함된 후보키는 기본키로 부적합
   * 단순한 후보키를 기본키로 선택
 
## 대체키(alternative key)
* 기본키로 선택되지 못한 후보키. 대체키는 기본키를 대신할 수 있지만 기본키가 되지 못한 사유가 있을 수 있음
* 예) 고객 릴레이션의 대체키(고객이름, 주소)
![image](https://github.com/qlkdkd/Database/assets/71871927/cadb2124-2583-4eb2-a425-a22612c3ece2)
![image](https://github.com/qlkdkd/Database/assets/71871927/1844a0fe-d944-40a1-ab9b-1d4d8e14fa1a)

![image](https://github.com/qlkdkd/Database/assets/71871927/1be20cf8-7a60-4aca-a8d9-1c6d7d96ba22)

## 외래키(foreign key)
* 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합
* 릴레이션들 사이의 관계를 표현
* 참조하는 릴레이션: 외래키를 가진 릴레이션
* 참조되는 릴레이션: 외래키가 참조하는 기본키를 가진 릴레이션

![image](https://github.com/qlkdkd/Database/assets/71871927/d510e075-966b-41f7-9d4f-7f299094ba79)
고객릴레이션(속성 6개, 기본키: 고객아이디), 주문릴레이션(속성 6개, 기본키: 주문번호). 주문릴레이션의 주문고객 속성이 고객 릴레이션의 기본키인 고객아이디 속성을 참조하면 주문고객 속성을 외래키라고 한다. 외래키를 통해 고객 릴레이션과 주문 릴레이션이 관계를 맺어, 주문 릴레이션의 투플과 연관성있는 고객 릴레이션과 주문 릴레이션이 관계를 맺어, 주문 릴레이션의 투플과 연관성 있는 고객 릴레이션의 투플을 연결시킬 수 있다.

참조하는 릴레이션: 주문 릴레이션, 참조되는 릴레이션: 고객 릴레이션

![image](https://github.com/qlkdkd/Database/assets/71871927/02efceb5-3f9e-4529-a402-646a892b1224)
외래키가 되는 속성과 기본키가 되는 속성의 이름은 달라도 된다. 그림에서도 주문 릴레이션의 외래키인 주문고객 속성과 고객 릴레이션의 기본키인 고객 아이디 속성은 이름이 다르다. **하지만 외래키 속성의 도메인과 참조되는 기본키 속성의 도메인은 반드시 같아야 된다. 도메인이 같아야 연관성 있는 투플을 찾기 위한 비교 연산이 가능하기 때문이다.**

![image](https://github.com/qlkdkd/Database/assets/71871927/b3de513e-1948-4878-a36c-65bd1ccafc0e)
3개의 릴레이션은 외래키를 이용해 서로의 관계를 표현하고 있다. 상담 릴레이션의 학번 속성은 학생 릴레이션의 기본키인 학번 속성을 참조하는 외래키이고, 담당교사 속성은 교사 릴레이션의 기본키인 교사번호 속성을 참조하는 외래키이다. 그리고 상담 릴레이션의 기본키는 두 외래키인 학번과 담당 교사 속성의 조합으로 구성되어이싿. **하나의 릴레이션에는 외래키가 여러 개 존재할 수도 있고, 외래키를 기본키로 사용할 수도 있다.**

![image](https://github.com/qlkdkd/Database/assets/71871927/bf5fa6e4-78e4-445d-8b2f-da58d4396964)
* 외래키가 다른 릴레이션의 기본키를 참조하는 키라고 정의했지만, 반드시 다른 릴레이션을 참조할 필요는 없다. 참조하는 릴레이션과 참조되는 릴레이션이 같을 수 있다. 즐, 외래키 자신이 속한 릴레이션의 기본키를 참조하도록 외래키를 정의할 수도 있다.
* 외래키는 기본키를 참조하지만 기본키가 아니기 때문에 널 값을 가질 수 있다.

![image](https://github.com/qlkdkd/Database/assets/71871927/b99961a6-193b-41fb-905a-f013afe38e94)

---

# 2. 관계 데이터 모델의 제약

## 무결성 제약조건(integrity constraint)
* 데이터의 무결성을 보장하고 일관된 상태로 유지하기 위한 규칙
* 무결성: 데이터에 결함이 없는 상태, 즉 테이터가 정확하고 유효하게 유지된 상태

### 개체 무결성 제약조건(entity integrity constraint)
* 기본키를 구성하는 모든 속성은 널 값을 가질 수 없는 규칙
* 개체 무결성 제약조건을 만족시키려면 새로운 투플이 삽입되는 연산과 기존 투플의 기본키 속성 값이 변경되는 연산이 발생할 때 기본키에 널 값이 포함되는 상황에서는 연산의 수행을 거부하면 된다.
![image](https://github.com/qlkdkd/Database/assets/71871927/209558e6-6cf9-4938-b3d1-ad057f73e93a)

### 참조 무결성 제약 조건
* 외래키는 참조할 수 없는 값을 가질 수 없는 규칙: 외래키가 자신이 참조하는 릴레이션의 기본키와 상관이 없는 값을 가지게 되면 두 릴레이션을 연관시킬 수 없으므로 외래키 본래의 의미가 없어진다.
![image](https://github.com/qlkdkd/Database/assets/71871927/0f5d9f58-3c22-4181-b471-ade4332f29ba)

![image](https://github.com/qlkdkd/Database/assets/71871927/26418780-dffe-421d-8217-e9ae1d6b6394)
* 참조 무결성 제약조건을 만족시키려면 외래키가 참조 가능한 값만 가져야 하지만, 널 값을 가진다고 해서 참조 무결성 제약조건을 위반한 것으로 판단해서는 안된다. 주문고객 속성 값이 널이라는 것은 주문한 고객이 누구인지 모를 뿐, 고객 릴레이션에 존재하지 않는 고객이 주문한 것으로 판단하기 어렵기 때문이다.
